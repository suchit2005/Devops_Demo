// Load config
const configLoad = require('./config_vars');
var config = configLoad();

// Below code taken from https://gist.github.com/benjamingr/0237932cee84712951a2 to globally handle all unhandled promise rejections
// !! NOTE !! In an upcoming Node.js release, all unhandled promise rejections will terminate the Node.js process with a non-zero exit code
process.on('unhandledRejection', function(reason, p) {
  console.log(
    'Possibly Unhandled Rejection at: Promise ',
    p,
    ' reason: ',
    reason
  );
});

var https = require('https');
var fs = require('fs');
const enigma = require('enigma.js');
const WebSocket = require('ws');

var ret = '';
var sourceQVF = config.qsAppsDir + '/' + config.sourceQVF + '.qvf';

var options = {
  rejectUnauthorized: false,
  hostname: config.env === 'server' ? config.serverHost : config.desktopHost,
  port: 4242,
  path:
    '/qrs/app/upload?keepData=true&name=DevOps%20POC&xrfkey=abcdefghijklmnop',
  method: 'POST',
  headers: {
    'x-qlik-xrfkey': 'abcdefghijklmnop',
    'X-Qlik-User': 'UserDirectory=INTERNAL;UserId=sashin.patel',
    'Content-Type': 'application/vnd.qlik.sense.app',
    Accept: 'application/json, text/plain, */*'
  },
  key: fs.readFileSync('./cert/client_key.pem'),
  cert: fs.readFileSync('./cert/client.pem')
};

var post_req = https
  .request(options, function(res) {
    var post_response = '';
    res.on('data', function(chunk) {
      post_response += chunk;
    });
    res.on('end', function() {
      console.log(post_response);
      ret = JSON.parse(post_response);
      console.log('New app ID is ' + ret.id);
      replaceApp();
    });
  })
  .on('error', function(e) {
    console.log('Got error: ' + e.message);
  });

var post_data = fs.readFileSync(sourceQVF);
console.log('Uploading ' + sourceQVF);
post_req.write(post_data);
post_req.end();

function replaceApp() {
  options = {
    rejectUnauthorized: false,
    hostname: config.env === 'server' ? config.serverHost : config.desktopHost,
    port: 4242,
    path:
      '/qrs/app/' +
      ret.id +
      '/replace?app=' +
      config.sourceQVFID +
      '&xrfkey=abcdefghijklmnop',
    method: 'PUT',
    headers: {
      'x-qlik-xrfkey': 'abcdefghijklmnop',
      'X-Qlik-User': 'UserDirectory=INTERNAL;UserId=sashin.patel'
    },
    key: fs.readFileSync('./cert/client_key.pem'),
    cert: fs.readFileSync('./cert/client.pem')
  };

  var put_req = https
    .request(options, function(res) {
      var put_response = '';
      res.on('data', function(chunk) {
        put_response += chunk;
      });
      res.on('end', function() {
        console.log(put_response);
        deleteApp();
      });
    })
    .on('error', function(e) {
      console.log('Got error: ' + e.message);
    });

  console.log('Replacing existing app with uploaded app...');
  put_req.write('');
  put_req.end();
}

function deleteApp() {
  const eConfig = {
    schema: require(`./node_modules/enigma.js/schemas/qix/3.1/schema.json`),
    session: {
      host: config.env === 'server' ? config.serverHost : config.desktopHost,
      port: config.env === 'server' ? config.serverPort : config.desktopPort,
      secure: false
    },
    createSocket(url) {
      return new WebSocket(url, {
        ca: fs.readFileSync('./cert/root.pem'),
        key: fs.readFileSync('./cert/client_key.pem'),
        cert: fs.readFileSync('./cert/client.pem'),
        headers: {
          'X-Qlik-User': 'UserDirectory=INTERNAL;UserId=sashin.patel'
        }
      });
    }
  };

  console.log('Connecting to Engine');
  var qix = enigma
    .getService('qix', eConfig)
    .then(qix => qix.global.deleteApp(ret.id))
    .then(() => console.log('Deleted app ' + ret.id));
}
