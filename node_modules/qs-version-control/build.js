const enigma = require('enigma.js')
const schema = require('enigma.js/schemas/3.1.json')
const WebSocket = require('ws')
const fs = require('fs')
const path = require('path')
const buildapp = require('./lib/buildapp')

module.exports = async function build(config) {
  console.log('Start of build process')

  // Get the source directory for serialized data
  const targetJSON = path.resolve(config.targetJSON)
  // Get the target doc based on whether the config file is for QS Desktop or Enterprise
  const doc =
    config.env_type === 'desktop'
      ? config.sourceQVF + '.qvf'
      : config.sourceQVFID
  console.log('Source directory is ' + targetJSON)
  const result = {} // Empty JSON

  // Configure the Enigma session
  console.log('Configuring Enigma session')
  // Use a non-secure websocket for desktop
  const session = enigma.create({
    schema,
    url:
      config.env_type === 'desktop'
        ? 'ws://' +
          config.desktopHost +
          ':' +
          config.desktopPort +
          '/app/engineData'
        : 'wss://' +
          config.serverHost +
          ':' +
          config.serverPort +
          '/app/engineData',
    // Get certificates from /cert directory
    createSocket: url =>
      new WebSocket(url, {
        ca: [fs.readFileSync('./cert/root.pem')],
        key: fs.readFileSync('./cert/client_key.pem'),
        cert: fs.readFileSync('./cert/client.pem'),
        // Temp workaround for non-secure connection errors
        checkServerIdentity: function(host, cert) {
          return undefined
        },
        // Set the X-Qlik-User header based on the config file
        headers: {
          'X-Qlik-User':
            'UserDirectory=' + config.userDirectory + ';UserId=' + config.userId
        }
      })
  })

  // Read each serialized JSON component
  // Load script is stored as a .qvs
  Object.keys(config.components).map(component => {
    if (component === 'loadScript') {
      result[component] = fs.readFileSync(
        path.join(`${targetJSON}`, `${component}.qvs`),
        'utf-8'
      )
      return
    }
    result[component] = JSON.parse(
      fs.readFileSync(path.join(`${targetJSON}`, `${component}.json`), 'utf-8')
    )

    console.log('Read ' + component)
  })

  // Override data connections as per config
  result['dataconnections'] = config.dataconnections
  result['reload'] = true

  console.log('Opening Enigma session')

  // Open session
  const global = await session.open()

  // If running against QS Desktop delete any existing QVF with the same name
  if (config.env_type === 'desktop') {
    try {
      await global.deleteApp(doc)
      console.log('An existing app was found and has been deleted')
    } catch (e) {
      // No existing QVF with the same name exists
      console.log('Could not find or delete an existing app')
      console.log(e)
    }
  }

  // Build the app
  console.log('Building app ' + result.properties.qTitle)
  try {
    var appId = await buildapp(global, result)
    console.log('App built successfully')

    // If running against QS Enterprise, replace the target app with the new app
    if (config.env_type != 'desktop') {
      console.log('New app ID is ' + appId)
      await global.copyApp(config.sourceQVFID, appId, [])
      console.log('Replaced ' + config.sourceQVFID + ' with ' + appId)
      await global.deleteApp(appId)
      console.log('Deleted ' + appId)
    }

    console.log('End of build process - exiting with success')
    session.close()
    process.exit(0)
  } catch (e) {
    console.log('!!! ERROR !!! ' + e)
    console.log('End of build process - exiting with failure')
    process.exit(1)
  }
}
